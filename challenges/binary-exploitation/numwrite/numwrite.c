/* gcc -O0 -g3 numwrite.c -o numwrite -fno-stack-protector -no-pie
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
*/

/* numwrite -- write numbers to a file and save it to the local directory
Copyright (C) 1986 Magpie Electronic Machines Inc.
All rights reserved.

numwrite writes a user specified amount of numbers to a new user specified
file in the local directory.  

Written by Dennis R.  Updates written by Wren Kucharik.
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

// This is a weird way to do this Wren.  I see what you're doing with it, but
// there's got to be a better way to implement this.  Also, why did you
// add char as an option?!  They only asked us to add int!
typedef struct numType{
	int i;
	long l;
	char c;
} numType;

// I know you didn't write this part, it's part of the original code, but
// if you could TRY to figure out a way to not use execv and just relying on 
// the echo program.  I'm just so happy no one has found out we're doing it
// that way!
void write_numbers(char* s) {
    char * args[] = { "/bin/bash", "-c", s, NULL};
    execv("/bin/bash", args);
}

void enter_numbers(int numbers, char* varType, char* echo_string) {

    int counter;
    long* list;
	numType types;
	int size;

	// Interesting.  I like that it defaults to long!  I still don't get why
	// you added char as an option.
	if(!strcmp(varType, "c")){
		size = numbers * sizeof(types.c);
	} else if(!strcmp(varType, "i")){
		size = numbers * sizeof(types.i);
	} else if(!strcmp(varType, "l")){
		size = numbers * sizeof(types.l);
	} else {
		size = numbers * sizeof(long);
	}

	// Yup
	list = (long *) alloca(size);

	// Something weird might be happening in here.  It seems to work for longs,
	// but when I use int it sometimes works and sometimes doesn't and I can't
	// see why.  Test it some more and see if you can figure it out, ok Wren?
    printf("Input your numbers one at a time. Biggest number is 4,294,967,295.\n");
    for (counter = 1; counter <= numbers; counter++) {
            printf("Number %d/%d: ", counter, numbers);
            scanf("%ld", &list[counter-1]);
    }

	// This is where we just use echo, *sigh*
	strcpy(echo_string, "echo \"");

    for(int i = 0; i < numbers; i++){
            char temp[10];
            sprintf(temp, " %ld", list[i]);
            strcat(echo_string, temp);
    }

    strcat(echo_string, "\" > ");
}

// You're hard coding the file name?!?!  It's supposed to be set by the
// user as a command line argument!  Also, why is this global now?!
char output_file[] = "output.txt";
char varType[3];
char buffer[20];

// You've made some serious changes here Wren, this isn't really the same
// program as before.  See my notes below.
int main(int argc, char **argv) {

	setvbuf ( stdout, NULL , _IONBF , 0 );

	// Wren.  This. is. a. command. line. utility.  It's supposed to take
	// all the information as command line arguments!  Why are you doing
	// it this way!?!?
	printf("How many numbers do you want to write?\n");
	scanf("%s", buffer);

	// AGIAN!?
	printf("\nWhat variable size do you want to use? (default is long)\n");
	printf("c: char		i: int		l: long\n");
	scanf("%s", varType);

	// Yeah,  limit the number of user input numbers to 256 for now for testing.  
	int input_numbers = atoi(buffer);
	if (input_numbers > 256 || input_numbers <= 0) {
			printf("Invalid input.  Select a number between 1 and 256 (inclusive).\n");
			exit(0);
	}

	int echo_size = input_numbers * 25 + 8;
    char* echo_string = alloca(echo_size);
	char* end_echo = alloca(32);

    enter_numbers(input_numbers, varType, echo_string);
	
	strcat(echo_string, output_file);

	write_numbers(echo_string);

    return 0;
}
