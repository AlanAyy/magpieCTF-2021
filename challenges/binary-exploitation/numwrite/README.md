# Magpie2021 - numwrite
### Category: Binary Exploitation
### Author: Jeremy Stuart (Mr.Wizard) 

## Description
Magpie Electronic Machines Inc. is working on an upgrade to our loved numwrite utility.  Our top people are working on speeding it up, and adding more options that will allow you to write numbers to a file!

## Hints

1. Wren let you choose what type of variable you want to allocate space for, but not the type of variable that is being written

2. read about how atoi works

3. Why is that buffer so big?  What else do you think it could hold?

## Solution:
This program has so many problems that there are likely many possible solutions.  Here is an overview of this solution.  We take advantage of the memory misallocation in `enter_numbers`

This solution takes advantage of the misallocation of memory in the enter_numbers function.  Line 54 allocates memory for the list of numbers `list = (long *) alloca(size);` but notice that it's allocating the size based on the variable type we've chosen, but it's still setting list to be a `long *` which means that if we choose `i` as our varialbe type then it will allocate space for ints, but still write the numbers into memory as longs.  This will sometimes cause problems for choosing `i` but not always, specifically not if we only write a few numbers in.  Using this misallocation of memory, we can start to take control of the program!

I start by telling the program that the number of numbers I want to write is `12AA/bin/sh`.  This is going to be stored in the buffer variable, which means that `/bin/sh` will exist as a string in memory, and we can use that later!  The program doesn't crash because it uses `atoi` to get the number we wrote in, and `atoi` only reads the number part of the input and leaves rest where it is.

Next we decide we want to write integers.  This means that space is allocated for 12 ints, but the program is going to write longs.  Once it asks for numbers, we write `-` (dash) 11 times.  This is because scanf interprets the dash as a kind of "pass" command, and writes nothing.  Remember, we only have enough space for 12 ints, not 12 longs, so after about the first 3 numbers we start to overwrite the stack frame of `enter_numbers`.  Once we get to number "12/12" we write `103079215104`.  Why?  Because this memory address is storing the `counter` variable which controls the top limit of our loop, that limit is currently 12.  And it's important to note that the 12 is being held in what looks like the upper part of the register.  `103079215104` translates to hex as `1800000000` and 18 in hex is 24.  This means the top limit of our loop gets changed from 12 to 24 we can continue to write into the stack frame of `enter_numbers`.  In fact - if you analyze it in gdb - you should notice that the return address to main is going to be the 22nd number you're going to write.  This means we can now overwrite the return address and gain control of execution flow.

We write 9 more `-` (dash) arguments to get to number 22/24.  This is going to be the return address of the stack frame for enter_numbers.  We overwrite it with the rop gadget "pop rdi; ret" to load an argument, and using ROPgadget we can find that it's located at `0x401743` which we can input as the decimal equivilent `4200259`.  What argument do we load?  The one we store in the buffer earlier: `/bin/sh`.  We find the address of `buffer` is 0x4040b0, but notice we argument we put in is `12AA/bin/sh` so we advance that address by 4 bytes so that it starts at `/bin/sh` and doesn't include `12AA`.  Where do we go from there?  We jump to `write_numbers`.  Notice that `write_numbers` uses /bin/bash and then executes some argument given to it.  That argument is supposed to be `echo <numbers we entered> > output.txt` but we've used a rop gadget to load in /bin/sh which means we will run a shell as root, and this gains us our command line!

Finish by typing `cat flag.txt` to get the flag.

## Flag: 
magpie{th3_w0rd_0f_7h3_d4y_|s_b1n4ry_3xpL0iT4t10n}