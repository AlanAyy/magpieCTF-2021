//g++ -D_FORTIFY_SOURCE=2 -std=c++17 -no-pie -fstack-protector-strong -fno-exceptions -Wl,--as-needed,-z,relro,-z,now -O3 -o poly poly.cpp
// RELRO:    Full RELRO
// Stack:    Canary found
// NX:       NX enabled
// PIE:      No PIE (0x400000)
#include <cstring>
#include <fstream>
#include <iostream>
#include <limits>
#include <optional>
#include <string>
#include <vector>

#define STR_MAX 100

// --------------------------------------------------------------------

extern "C"
{
	void win();
}

void win()
{
	std::ifstream flag("flag.txt");
	if (!flag.is_open())
	{
		std::cout << "Could not open flag file." << std::endl;
		return;
	}

	std::string line;
	if (std::getline(flag, line))
		std::cout << line << std::endl;
}

std::optional<int> parseInt(const char* s)
{
	char *end = nullptr;

	long l = strtol(s, &end, 10);
	if (s == end)
		return std::nullopt;
	
	if (l < std::numeric_limits<int>::min() || l > std::numeric_limits<int>::max())
		return std::nullopt;;

	return (int)l;
}

char* readLine(char* s, int n)
{
	if (std::cin.getline(s, n))
		return s;

	std::cin.clear();
	std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
	return nullptr;
}

// --------------------------------------------------------------------

class Base
{
public:
	virtual ~Base() = default;
	virtual bool update(const char* s) = 0;

	template<class T>
	static Base* factory(T x) { return Base::factoryInternal(x); }

	unsigned long getId() const { return m_id; }
	static unsigned long nextId() { return s_idCounter; }

protected:
	Base()
		: m_id(s_idCounter++)
	{}

private:
	static unsigned long s_idCounter;

	static Base* factoryInternal(int i);
	static Base* factoryInternal(const char* s);

	unsigned long m_id;
};

unsigned long Base::s_idCounter = 0;

// --------------------------------------------------------------------

class IntType : public Base
{
public:
	IntType(int i)
		: m_int(i)
	{}
	virtual bool update(const char* s) override
	{
		auto var = parseInt(s);
		m_int = var.value_or(0);
		return var.has_value();
	}

private:
	int m_int;
};

// --------------------------------------------------------------------

class StringType : public Base
{
public:
	StringType(const char* s)
		: m_str(s)
	{}
	virtual bool update(const char* s) override
	{
		if (strlen(s) >= STR_MAX)
			return false;
		m_str = s;
		return true;
	}

private:
	std::string m_str;
};

// --------------------------------------------------------------------

Base* Base::factoryInternal(int i) { return new IntType(i); }
Base* Base::factoryInternal(const char* s) { return new StringType(s); }

// --------------------------------------------------------------------

int menu()
{
	char buf[2];
	std::cout   <<  "\n"
					"1. Add Item\n"
					"2. Update All\n"
					"> ";

	if (char* in = readLine(buf, 2))
		if (auto maybeInt = parseInt(in))
			if (int i = maybeInt.value_or(0))
				return (i>=1 && i<=2) ? i : 0;

	return 0;
}

Base* create()
{
	char in[STR_MAX];

	std::cout << "Enter Value: " << std::flush;
	if (!readLine(in, STR_MAX))
		return nullptr;

	if (auto maybeInt = parseInt(in))
		return Base::factory(maybeInt.value_or(0));
	
	if (in[0] != '\0')
		return Base::factory(in);
	
	return nullptr;
}

int main(void)
{
	std::cout << "Welcome!\n";

	using ItemList = std::vector<Base*>;
	ItemList items;
	items.reserve(10);
	
	while (true)
	{
		switch (menu())
		{
			case 1:
				std::cout << "Creating Item " << Base::nextId() << "!" << std::endl;
				if (Base* b = create())
					items.push_back(b);
				else
				{
					std::cout << "Unknown Error. No Item Created." << std::endl;
				}
				
				break;

			case 2:
				std::cout <<	"Updating Items\n"
								"---\n";

				for (auto it = items.begin(), end = items.end(); it != end; ++it)
				{
					Base* item = *it;
					std::string line(20,'\0');

					std::cout << "Enter new value for item " << item->getId() << ": " << std::flush;
					std::getline(std::cin, line);

					if(line[0] == '\0')
						continue;

					if (!item->update(line.c_str()))
					{
						std::cout << "Unknown Error. Item will be removed." << std::endl;
						items.erase(it);
						delete item;
					}
				}
				std::cout << "---\n\n";

				break;

			default:
				std::cout << "Bye!" << std::endl;
				return 0;
				break;
		}
	}

	return 0;
}
