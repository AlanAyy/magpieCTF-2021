# Poly
### Category: Binary Exploitation
### Author: steadmanticore

## Description
Modern C++ is a mashup of an evolving stdlib built on-top of a 1980-era framework of classes and polymorphism. Mastery of both will be required to coax the flag from this binary.

## Hints
1. https://en.cppreference.com/w/cpp/container/vector/erase
2. vtable
3. pwntools ues a pty for stdout by default. Libc allocates I/O buffers differently for ptys – changing the heap offsets. Try again without a pty.

## Solution
The issue is the code can erase from the vector<> while iterating through it. When that happens, the list is shorter AND the iterator increments AND the previous `end()` of the list is cached, which means the loop will continue past the end of the current list, and de-reference a stale pointer, which is always a duplicate of the last pointer in the vector.

If you set up a situation where the last item on the list has also been erased, then the “extra” loop iteration will point at free memory. In this version of libc, the displayed id of the free memory will be the address of the base heap structure for the current thread – giving you a heap leak.

If you setup your heap so that the std::string holding the input for the current line overlaps with the memory that was just freed (by having it just the right length so the same chunk is returned from the t-cache), then you can craft a fake “base” instance. The first 8 bytes of this instance is a pointer to a vtable. Inside the vtable is a list of function pointers. The code will unconditionally call the function pointer for update(). You need to create a fake vtable that has the pointer for update() replaced with a pointer to win(). You then need to ensure that the first 8 bytes of your fake instance points at the start of this vtable. When this happens, win() will be called and the flag will be printed.

The biggest gotcha is that pwntools will allocate a pty for stdout by default – which will cause libc to allocate a buffer of 1024 bytes instead of 4096. This will change the heap offsets by 3072 bytes. This can be tested either by changing pwntools to use a PIPE for stdout, or launching the binary with socat and connecting to the port.

Example: `socat -d -d tcp-l:5555,reuseaddr exec:"./poly”` - and then connect to localhost:5555. This will connect stdin/stdout to a SOCKET, not a pty, which means the heap allocations will match the server. 

## Flag
magpie{P0LYm0RPhi5M_4_7H3_wiN_a935ef442} 